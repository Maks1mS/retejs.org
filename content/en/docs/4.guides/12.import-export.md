# Import/export

По умолчанию редактор может принимать в качестве узлов и соединений любые JS объекты, которые должны иметь обязательное поле `id` для узлов и соединений, а также `source` и `target` для соединений. Это могут быть как простые объекты с данными, так и объекты с методами.

Данная версия редактора не имеет встроенной поддержки импорта/экспорта по нескольким причинам (все они описаны детально ниже):

- Сериализация узлов/соединений в JSON не всегда является тривиальной задачей
- Порядок импорта узлов может отличаться зависимо от вашей структуры графа

#### Valid JSON objects

Рассмотрим простой случай, где узел является валидным JSON объектом

```ts
import { NodeEditor, ClassicPreset, BaseSchemes, getUID } from 'rete'

const editor = new NodeEditor<BaseSchemes>()

const node = { id: getUID(), label: 'Label' }

await editor.addNode(node)
```

В данном случае мы можем легко экспортировать такие узлы в JSON, чтобы в дальнейшем сохранить в базу или тому подобное.

#### Non-valid JSON objects

Сложнее дела обстоят с объектами, которые не являются валидным JSON. Например, экземпляры классов, объекты с функциями или объекты, имеющие циклические ссылки. Мы могли бы отказаться от всего этого, но тогда мы потеряем преимущества, которые дает нам JS.

Например, мы можем создавать узлы с помощью классов и взаимодействовать с ними через методы. Это может быть намного надежнее и удобнее, поскольку мы можем использовать различные парадигмы.

```ts
import { ClassicPreset } from 'rete'

const node = new ClassicPreset.Node('Label')

node.addOutput('port', new ClassicPreset.Output(socket, 'Label'))

await editor.addNode(node)
```

Разумеется, мы могли бы применить какой-то вид сериализации с последующей десериализацией, чтобы преобразовать такие объекты в валидный JSON, но скорее такой подход будет плохо работать в случаях отличных от простых.

#### Экспортируем и импортируем узлы

Рассмотрим пример как экспортировать граф. Ниже приведен приблизительный код как это должно выглядеть, но он не является полнофункциональным и является ознакомительным, чтобы вы могли реализовать свой импорт/экспорт с оглядкой на ваш функционал

```ts
const data = { nodes: [] }
const nodes = editor.getNodes()

for (const node of nodes) {
  data.nodes.push({
    id: node.id,
    label: node.label,
    inputs: /// ....
    controls: /// ....
    outputs: /// ....
  })
}
```

В обратную сторону нам нужно на основе объектов инициализировать экземпляры узла, входов, выходов и контролов.

```ts
for (const { id, label, inputs, outputs, controls } of data.nodes) {
  const node = new ClassicPreset.Node(label);

  node.id = id;

  /// ... inputs
  /// ... controls
  /// ... outputs

  await editor.addNode(node)
}
```

Полный пример вы можете найти [по ссылке](https://codesandbox.io/s/rete-js-v2-import-export-999y8z?file=/src/index.ts:3276-3465), который в свою очередь также сильно упрощен

#### Import nodes order

Другой проблемой при импорте графов может быть порядок, согласно которому должны импортироваться узлы. В простом случае их порядок будет идентичен порядку их добавления в редактор

```ts
const graph = /// loaded JSON-valid object from DB

for (const node of graph.nodes) {
  await editor.addNode(node)
}
```

В случае с более сложными графами порядок может быть иной. К примеру, в графе с вложенными узлами может потребоваться сначала добавлять родительские узлы, а только потом дочерние, и вполне возможно, что на момент работы в редакторе пользователем может быть создан сначала дочерний узел, а потом родительский.

Рассмотрим пример импортирования такого графа, где некоторые узлы имеют поле `parent`, указывающее на их принадлежность к другому узлу, а значит такие узлы должны быть импортированы после создания их родительского узла

```ts
async function importForParent(nodes, parent = undefined) {
  const nodes = nodes.filter(node => node.parent === parent)

  for (const node of nodes) {
    await editor.addNode(node)
    await importForParent(nodes, node.id)
  }
}

const graph = /// loaded JSON-valid object from DB

await importForParent(graph.nodes)
```

Как видим, этот подход сложнее, и он далеко не единственный, поэтому способ импортирования будет зависеть в вашем конкретном случае


