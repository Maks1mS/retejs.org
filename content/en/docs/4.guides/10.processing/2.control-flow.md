# Control flow

::alert
Если вы не знакомы с концепцией Control flow, советуем ознакомиться со статьей [Control flow](../../concepts/engine#control-flow)
::

#### Устанавливаем зависимости

```bash
npm i rete@next rete-engine@next
```

#### Подготавливаем узлы

Рассмотрим упрощенный пример графа с двумя типами узлов: `Log` и `Delay`. Каждый из них может выполнять свои операции и определенным образом передавать управление исходящим узлам.

Ссылку на полный пример с визуальной частью вы можете найти в конце статьи.

Определяем класс узла, который будет логировать сообщение и передавать управление исходящим узлам по порту `"exec"`

```ts
const socket = new ClassicPreset.Socket("socket");

class Log extends ClassicPreset.Node {
  constructor(public message: string) {
    super("Log");

    this.addInput("exec", new ClassicPreset.Input(socket, "Exec", true));
    this.addOutput("exec", new ClassicPreset.Output(socket, "Exec"));
  }

  execute(input: "exec", forward: (output: "exec") => void) {
    console.log(this.message);
    forward("exec");
  }
}
```

Определяем класс для выполнения задержки. Единственная его задача - по таймауту передавать управление исходящим узлам по порту `"exec"`

```ts
class Delay extends ClassicPreset.Node {
  constructor(private seconds: number) {
    super("Delay");
    this.addInput("exec", new ClassicPreset.Input(socket, "Exec", true));
    this.addOutput("exec", new ClassicPreset.Output(socket, "Exec"));
  }

  execute(input: "exec" | undefined, forward: (output: "exec") => void) {
    setTimeout(() => forward("exec"), seconds * 1000)
  }
}

class Connection<A extends NodeProps, B extends NodeProps> extends ClassicPreset.Connection<A, B> {}

type NodeProps = Start | Log | Delay;
type ConnProps =
  | Connection<Start, Log>
  | Connection<Delay, Log>
  | Connection<Log, Delay>
  | Connection<Log, Log>
  | Connection<Delay, Delay>;
type Schemes = GetSchemes<NodeProps, ConnProps>;
```

#### Подключение

```ts
import { ControlFlowEngine } from "rete-engine";
import { NodeEditor } from "rete";

const editor = new NodeEditor<Schemes>();
const engine = new ControlFlowEngine<Schemes>();

editor.use(engine);
```

#### Добавляем узлы и соединения

Добавим последовательность узлов в виде Log -> Delay -> Log

```ts
const log1 = new Log("log before delay");
const delay = new Delay(2);
const log2 = new Log("log after delay");

const con2 = new Connection(log1, "exec", delay, "exec");
const con3 = new Connection(delay, "exec", log2, "exec");

await editor.addNode(log1);
await editor.addNode(delay);
await editor.addNode(log2);

await editor.addConnection(con2);
await editor.addConnection(con3);
```

#### Исполнение

Начинаем исполнение графа с узла `log1`.

```ts
engine.execute(log1.id);
```

Данный вызов метода вызывает метод `execute` класса `Log`, передавая ему `undefined` в качестве параметра `input`, поскольку вызов данного узла был прямым, а не передан от входящего узла.
Далее при вызове `forward("exec")` узел передает управление всем исходящим узлам. В нашем случае это будет `Delay`, который делает то же самое, только после задержки, используя `setTimeout`

Результатом исполнения будет следующий вывод

```log
"log before delay"
// delay for 2 seconds
"log after delay"
```

Готовый результат вы можете найти на странице примера [Control flow](/examples/control-flow)
