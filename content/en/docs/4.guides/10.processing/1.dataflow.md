# Dataflow

::alert
Если вы не знакомы с концепцией Dataflow, советуем ознакомиться со статьей [Dataflow](../../concepts/engine#dataflow)
::

#### Устанавливаем зависимости

```bash
npm i rete@next rete-engine@next
```

#### Подготавливаем узлы

Рассмотрим упрощенный пример графа с двумя типами узлов: `NumberNode` и `AddNode`. Они рассчитаны только на обработку (например на серверной стороне) и не имеют каких-либо интеграций с пользовательским интерфейсом. Ссылку на полный пример с визуальной частью вы можете найти в конце статьи.

```ts
const socket = new ClassicPreset.Socket("socket");

class NumberNode extends ClassicPreset.Node {
  constructor(public value: number) {
    super("Number");
    this.addOutput("value", new ClassicPreset.Output(socket, "Number"));
  }

  data(): { value: number } {
    return { value: this.value };
  }
}

class AddNode extends ClassicPreset.Node {
  constructor() {
    super("Add");
    this.addInput("left", new ClassicPreset.Input(socket, "Left"));
    this.addInput("right", new ClassicPreset.Input(socket, "Right"));
    this.addOutput("value", new ClassicPreset.Output(socket, "Number"));
  }

  data(inputs: { left?: number[]; right?: number[] }): { value: number } {
    const { left, right } = inputs;
    const value = (left && left[0] || 0) + (right && right[0] || 0)

    return { value };
  }
}

class Connection<
  A extends Node,
  B extends Node
> extends ClassicPreset.Connection<A, B> {}

type Node = NumberNode | AddNode;
type ConnProps = Connection<NumberNode, AddNode> | Connection<AddNode, AddNode>;
type Schemes = GetSchemes<Node, ConnProps>;
```

#### Подключение

```ts
import { DataflowEngine } from "rete-engine";
import { NodeEditor } from "rete";

const editor = new NodeEditor<Schemes>();
const engine = new DataflowEngine<Schemes>();

editor.use(engine);
```

#### Добавляем узлы и соединения

```ts
const a = new NumberNode(1);
const b = new NumberNode(1);
const sum = new AddNode();

const con1 = new Connection(a, "value", c, "left");
const con2 = new Connection(b, "value", c, "right");

await editor.addNode(a);
await editor.addNode(b);
await editor.addNode(sum);

await editor.addConnection(con1);
await editor.addConnection(con2);
```

#### Запускаем обработку

Запрашиваем выходные данные узла `sum`

```ts
const result = await engine.fetch(sum.id)
```

В результате `result` будет иметь значение `{ value: 2 }`, которое является результатом суммирования первых входных значений узла `sum`

Если мы хотим изменить `a.value` или `b.value`, перед следующей обработкой графа необходимо очистить кэш. Все выходные значения узлов кэшируются с целью предотвратить повторное исполнение узлов

```ts
engine.reset() // reset all nodes
// or specific nodes
engine.reset(a.id)
engine.reset(b.id)
```

Кроме этого, методы `data` могут быть асинхронными. В таком случае, узел `sum` будет дожидаться выполнения методов `data` его входящих узлов, и как только все они вернут результат, движок запустит метод `data` узла `sum`

Готовый результат вы можете найти на странице примера [Dataflow](/examples/dataflow)
