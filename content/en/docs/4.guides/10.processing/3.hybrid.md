# Hybrid Engine

::alert
Для краткого ознакомления с концепцией совмещения Dataflow и Controlflow, советуем ознакомиться со статьей [Hybrid](../../concepts/engine#hybrid)
::
#### Устанавливаем зависимости

```bash
npm i rete@next rete-engine@next
```

#### Подготавливаем узлы

Все классы узлов должны иметь метод `execute` для Control flow и метод `data` для Dataflow

Класс `Start` отвечает только за передачу управления, и по умолчанию имеет `data`, возвращающий пустой объект

```ts
const socket = new ClassicPreset.Socket("socket");

class Start extends ClassicPreset.Node {
  constructor() {
    super("Start");
    this.addOutput("exec", new ClassicPreset.Output(socket, "Exec"));
  }

  execute(_: never, forward: (output: "exec") => void) {
    forward("exec");
  }

  data() {
    return {};
  }
}
```

Класс `Log` в свою очередь может не только принимать управление, но и запрашивать данных от входящего узла через порт `"message"`. Это делается с помощью вызова метода `fetchInputs` у экземпляра `DataflowEngine`

```ts
class Log extends ClassicPreset.Node {
  constructor() {
    super("Log");

    this.addInput("exec", new ClassicPreset.Input(socket, "Exec", true));
    this.addInput("message", new ClassicPreset.Input(socket, "Text"));
    this.addOutput("exec", new ClassicPreset.Output(socket, "Exec"));
  }

  async execute(input: "exec", forward: (output: "exec") => void) {
    const inputs = (await dataflow.fetchInputs(this.id)) as {
      message: string[];
    };

    console.log((inputs.message && inputs.message[0]) || "");

    forward("exec");
  }

  data() {
    return {};
  }
}
```

Класс `TextNode` отвечает только за предоставление данных и не может принимать или передавать управление

```ts
class TextNode extends ClassicPreset.Node {
  constructor(private text: string) {
    super("Text");
    this.addOutput("value", new ClassicPreset.Output(socket, "Number"));
  }

  execute() {}

  data(): { value: string } {
    return {
      value: this.text
    };
  }
}

class Connection<A extends NodeProps, B extends NodeProps> extends ClassicPreset.Connection<A, B> {}

type NodeProps = Start | Log | TextNode;
type ConnProps = Connection<Start, Log> | Connection<TextNode, Log>;
type Schemes = GetSchemes<NodeProps, ConnProps>;

```

#### Подключение

```ts
import { NodeEditor } from "rete";
import { DataflowEngine, ControlFlowEngine } from "rete-engine";

const editor = new NodeEditor<Schemes>();
const dataflow = new DataflowEngine<Schemes>(({ inputs, outputs }) => {
  return {
    inputs: Object.keys(inputs).filter((name) => name !== "exec"),
    outputs: Object.keys(outputs).filter((name) => name !== "exec")
  };
});
const controlflow = new ControlFlowEngine<Schemes>(() => {
  return {
    inputs: ["exec"],
    outputs: ["exec"]
  };
});

editor.use(dataflow);
editor.use(controlflow);
```

#### Добавляем узлы и соединения

```ts
const start = new Start();
const text1 = new TextNode("log");
const log1 = new Log();

const con1 = new Connection(start, "exec", log1, "exec");
const con2 = new Connection(text1, "value", log1, "message");

await editor.addNode(start);
await editor.addNode(text1);
await editor.addNode(log1);

await editor.addConnection(con1);
await editor.addConnection(con2);
```

#### Исполнение

Начинаем исполнение графа с узла `start`.

```ts
engine.execute(start.id);
```

В результате узел `start` передаст управление узлу `log1`, который в свою очередь запрашивает данные у узла `text1` через метод `fetchInputs`

Готовый результат вы можете найти на странице примера [Hybrid engine](/examples/hybrid-engine)

