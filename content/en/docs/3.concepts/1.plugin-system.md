# Plugin system

::alert
Обратите внимание, что данный API может быть изменен пока текущая версия находится в Beta
::

В первую очередь плагины это возможность подключить новый функционал с помощью одной точки входа (в основном). Между собой плагины коммуницируют с помощью сигналов, которые распространяются от родительских плагинов к дочерним. Поскольку плагины могут иметь несколько дочерних плагинов, то такие сигналы проходят через эти плагины в порядке их подключения (может быть важно при подключении таких плагинов как readonly)

Пример кода, где мы создаем два скоупа, один из которых является дочерним, и оба логируют сигналы

```ts
import { Scope } from 'rete';

const parentScope = new Scope<number>('parent'); // number is produced type
const childScope = new Scope<string, [number]>('child'); // [number] is expected types of parents chain

parentScope.addPipe((context) => { // add pipe to parent scope
  console.log('parent', context); // number

  return context;
});

childScope.addPipe((context) => { // add pipe to child scope
  console.log('child', context); // string | number

  return context;
});

parentScope.use(childScope); // forward all signals to child scope

const returnedNumber = await parentScope.emit(1); // can emit number
const returnedString = await childScope.emit('a'); // can emit string
```

Вывод. Обратите внимаение, что порядок вызова use и addPipe влияет на порядок вызова родительского и дочерних обработчиков
```log
parent 1
child 1
child a
```

Сигналы могут быть модифицированы или предотвращены в отдельных случаях.

```ts
parentScope.addPipe((context) => {
  return context * 2;
});
childScope.addPipe((context) => {
  if (context === 'b') return // prevent propagation of numbers
  return context;
});

const doubledNumber = await parentScope.emit(1); // 2
const expectedString = await childScope.emit('a'); // 'a'
const expectedUndefined = await childScope.emit('b'); // undefined
```

Благодаря статической типизации, подключаемые плагины проверяются на совместимость ожидаемых сигналов и тех, которые производит родительский плагин.

```ts
import { Scope } from 'rete';

const parentScope = new Scope<number>('parent');
const childScope = new Scope<string, [number | boolean]>('child');

parentScope.use(childScope); // Type 'boolean' is not assignable to type 'string | number'.ts(2345)
```

Также дочерние плагины могут получить доступ к экземпляру родительского плагина как для непосредственного доступа к его интерфейсам, так и для продуцирования сигналов от имени родительского плагина.

```ts
import { Scope } from 'rete';

class Root extends Scope<number> {
  isRoot = true
}

class Root2 extends Scope<number> {
  isRoot2 = true
}

const parentScope = new Root('parent');
const childScope = new Scope<string, [number]>('child');

parentScope.use(childScope);

const parent = childScope.parentScope(); // Root instance, but Scope from TS perspective
const root = childScope.parentScope<Root>(Root); // Root instance
const wrongInstance = childScope.parentScope<Root2>(Root2); // throws exception
```
