
# Intergartion

Данный фреймворк не привязан к какому-либо фреймворку для рендеринга UI и может быть интегрирован с самыми популярными фреймворками/библиотеками такими как Ангулар, Вью, Реакт.

Основная задача это позволить выбрать те средства для визуализации, которые вам больше всего подходят. Более того, если по каким то причинам вы хотите в приложении на одном фреймворке использовать рендер плагин для другого фреймворка (например при миграции проекта) - вы можете это сделать. Есть только одно ограничение `rete-angular-render-plugin` может быть использован только внутри Ангуляр приложения.

## Классический пресет

По умолчанию, вы можете использовать классический пресет, который имеет предопределенные компоненты для:

- узлов
- соединений
- некоторых контролов (числовое или текстовое поле ввода)

```ts
import { AngularRenderPlugin, AngularArea2D, Presets as AngularPresets } from 'rete-angular-render-plugin'

const angular = new AngularRenderPlugin<Schemes, AngularArea2D<Schemes>>({ injector })

angular.addPreset(AngularPresets.classic.setup({ area }))

area.use(angular)
```

При необходимости вы можете их заменить на любые другие компоненты. В частности компонент узла может быть кастомизирован до неузнаваемости. Детали см. в статье Кастомизация.

## Комбинирование рендер плагинов

В данной версии фреймворка были улучшены подходы в комбинировании разных фреймворков для рендеринга с учетом поддержки TS. К примеру, один узел может быть отрендерен с помощью Vue, а другой узел отрендерен с помощью Реакт.

```ts
import { ReactArea2D, ReactRenderPlugin, Presets as ReactPresets } from 'rete-react-render-plugin'
import { VueArea2D, VueRenderPlugin, Presets as VuePresets } from 'rete-vue-render-plugin'

type AreaExtra =
  | AreaExtra<Schemes>
  | VueArea2D<Schemes>

const reactPlugin = new ReactRenderPlugin<Schemes, AreaExtra>()
const vuePlugin = new VueRenderPlugin<Schemes, AreaExtra>()

reactPlugin.addPreset(ReactPresets.classic.setup({ area, customize: {
  node(data) {
    if (data.payload instanceof AddNode) return null // prevent rendering of AddNode by React.js
    return ReactPresets.classic.Node
  }
} }))
vuePlugin.addPreset(VuePresets.classic.setup({ area, customize: {
  node() {
    return VuePresets.classic.Node // render all nodes that weren't rendered by previously used render plugin
  }
} }))

// order matters
area.use(reactPlugin)
area.use(vuePlugin)
```

В этом примере AddNode рендерится с помощью Vue.js, а все остальные узлы с помощью React.js.

С одной стороны, такой подход и множество одновременно используемых фреймворков может плохо сказаться на производительности, с другой стороны это неплохой буст в прототипировании, когда скорость разработки намного важнее производительности (которую в дальнейшем можно улучшать при необходимости)

