# Development

Эта статья документации предназначена для тех, кто хочет разработать новые плагины, внести вклад в существующие или отладить их.

## Rete CLI

Rete CLI это инструмент, которые выполняет роль бандлера со встроенной поддержкой TypeScript и ESLint с преопределнными правилами. Также он имеет встроеный таск раннер Jest. Все это позволил вам легко начать разработку новых плагинов без необходимости самому настраивать окружение для сборки, линтинга и тестирования.

Сборщик основан на Rollup, имеет подключенные по Бабель пресеты для Тайпскрипт

### Установка

```bash
npm i -g rete-cli@next
```

### Сборка проекта

Сперва вам нужно создать конфиг, например, `rete.config.ts`:

```ts
import { ReteOptions } from 'rete-cli'

export default <ReteOptions>{
  input: 'src/index.ts', // путь к entry скрипту
  name: 'Namespace' // namespace для UMD бандлов
}
```

Выполняем команду

```bash
rete build --config rete.config.ts
```

В результате мы получим директорию `dist`, которая готова к публикации. Директория содержит бандлы трех видов, дефиниции типов, README.md и package.json с указанием путей к ним.

Кроме этого, вы можете воспользоваться опцией `--watch` для сборки проекта при сохранении, а также `--outputs` чтобы указать пути (через запятую) куда записывать результаты сборки.

### Создание продвинутой конфигурация

Рассмотрим несколько возможностей, которые поддерживает конфигурация:

- подключение Rollup плагинов
- обозначение внешних зависимостей, которые не должны быть включены в бандл
- произвольный выходной путь
- подключить плагины и пресеты Бабеля


```ts
import { ReteOptions } from 'rete-cli'

export default <ReteOptions>[ // config with multiple entries
  {
    input: 'src/foo/index.ts',
    name: 'Namespace'
    babel: {
      presets: [
        require('@babel/preset-env'), // used by default, but should be declared when you specifies 'presets'
        require('@babel/preset-typescript'), // used by default
        require('@babel/preset-react'),
      ]
    }
  },
  {
    input: 'src/bar/index.ts',
    name: 'Namespace'
    globals: {
      'rete': 'Rete',
    },
    plugins: [ // specify Rollup plugins
      commonjs(),
    ],
    babel: {
      plugins: [
        // include Babel plugins
      ]
    }
  }
]
```

### Линтинг

По умлчанию команда `rete build` перед генерированием бандлов выполняет линтинг, но вы можете отдельно выполнить линтинг командой

```bash
rete lint
```


## Rete Kit

Это инструмент, который направлен на повышение эффективности во время разработки плагинов или проектов, основанных на этом фреймворке.

Он включает в себя следующие возможности:

- Создание плагинов: создает базовую структуру плагина, который вы можете мгновенно начать разрабватывать, не тратя время на настройку сборщика, линтера и тест раннера
- Создание приложений: выберите фреймворк, на котором будет основываться ваше приложение, его версию и необходимые фичи - и в результате получайте приложение, с которого вы можете быстро начать разработку
- Массовая сборка: выберите копии репозиториев с исходным кодом разрабатываемых плагинов и этот инструмент начнет их сборку в режиме просмотра и синхронизирует их зависимости

### Установка

```bash
npm i -g rete-kit@next
```

### Создание приложения

В режиме опросника

```bash
rete-kit app
```

Или укажите опции

```bash
rete-kit app --name <name> --stack <stack> --stack-version <version> --features <features> --deps-alias <deps-alias>
```

где
- `<stack>` это одна из опций: angular, vue, vue-vite або react
- `<features>` - перечисленные через запятую фичи Rete.js редактора
- `<deps-alias>` - JSON файл с маппингом зависимостей (по умолчанию он устанавливает из npmjs по метке latest, но вы можете дугую версию в виде name@version или путь к tarball)

### Создание плагина

В самом простом случае вы можете создать плагин в пределах вашей кодовой базы и тогда вам не потребуется выделять это как отдельный пакет - просто следуйте примеру других плагинов и начинайте с расширения `Scope`.

Но если вы хотите создать плагин в виде отдельного пакета (например для распространения между несколькими проектами или даже для комьюнити), воспользуйтесь следующей командой:

```bash
rete-kit plugin --name <plugin name>
```

где `<plugin name>` это строка, которая будет преобразована в различные формы и использована для шаблона (например в rete.config.ts и имени package.json)

Полученный шаблон будет иметь все необходимые базовые настройки, и вы можете сразу начать работать с исходным кодом

### Сборка зависимостей для разработки

Процесс разработки модулей, которые разделены на разные пакеты, является достаточно нетривиальным процессом. В отличии от одной кодовой базы, где сборщик проекта может отслеживать изменения в директории и пересобирать проект используя hot reload, мы должны самостоятельно настроить сборку каждой зависимости, над которой мы работаем, и каким-либо образом доставить изменения в наш проект.

Мы могли бы использовать npm link, и в конце концов написать bash скрипт для сборки в режиме отслеживания всех модулей, которые нас интересует. Но к сожалению, npm link имеет некоторые ограничения, которые не не сразу можно обнаружить и нарваться на несколькочасовой дебагинг проблемы (это связано как раз с общими зависимости проекта и зависимостей, над которыми мы работаем).

Для решения подобных проблем была создана команда `rete-kit build`, которая которая может работать в двух режимах:

- сборка всех зависимостей проекта: укажите путь к вашему проекту, и инструмент рекурсивно (до двух уровней вложенности) просканирует текущую директорию на наличие репозиториев с исходным кодом зависимостей `rete` и в режиме отслеживания будет собрать их прямиком `node_modules`, в которых они используются

```bash
rete-kit build --for ./my-project
```

- сборка строго указанных директорий: в флаге `--folders` укажите перечень директорий с исходным кодом зависимостей, которые учитывать при сборке, и подобно первому режиму результат сборки будет внедрен в целевые `node_modules`

```bash
rete-kit build --folders my-plugin-1,my-plugin-1,my-project
```

Учтите, что полноценно работать с hot reload вы сможете в случае, если отключить кэш для нужных зависимостей, иначе изменеия не будут применяться на лету.
К примеру, в Webpack это можно сделать указав `snapshot.managedPaths`. В некоторых случаях даже перезапуска проекта будет недостаточно, поэтому придется вручную очистить кэш собранных модулей

## Style guide

Мы используем ESLint, чтобы обеспечить единый стиль кода во всей пакетах. Данный конфиг предоставляется инструментом Rete CLI и содержит правила, которые по мнению мейнтейнеров являются более подходящими. При крайней необходимости вы можете расширять конфиг, указав нужные правила.

Поскольку линтеры не могут покрыть все кейсы, вот дополнительно список рекомендаций:

- Комментирование: оставляйте комментарии только там, где это необходимо. Проверьте можно ли измежать лишних комментариев путем рефакторинга кода, чтобы сделать его более смысловным.
- Простота: соблюдайте баланс между переиспользованием кода и объемом boilterplate кода. Иногда boilerplate код является более уместным, чем переусложненные конструкции, которые нивелируют этот шаблонный код.
- Обработка ошибок и исключения: всегда корректно обрабатывайте ошибки и исключения, предоставляя полезные сообщения об ошибках. Убедитесь, что выбрасываемые исключения не нарушают работу приложения и обрабатываются изящно, если это возможно.
- Производительность: код должен быть достаточно оптимизировать, чтобы при большом количестве данных не возникало чрезмерных задержек, но в то же время не рекомендуется жертвовать поддерживаемостью кода ради микрооптимизаций
