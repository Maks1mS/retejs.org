# З’єднання

::alert
Цей гайд базується на гайді [Базовий редактор](/uk/docs/guides/basic). Рекомендується переглянути його для повного розуміння цього гайду.
::

::references
:ref-guide{title="Валідація" link="/docs/guides/validation#connections-validation"}
:ref-example{title="Чат-бот" link="/uk/examples/chatbot"}
::

Цей гайд містить більш детальне вивчення функціональних можливостей плагіна `rete-connection-plugin`, що забезпечує взаємодію користувача зі з’єднаннями.

Коли користувач натискає на сокет, з’єднання, що слідує за курсором, називається псевдоз’єднанням, яке є об’єктом із додатковою властивістю `isPseudo: true`.

## Пресети {#presets}

Можливо, ви вже бачили таке використання попередньо встановлених налаштувань, яке дозволяє користувачам додавати з’єднання, клацаючи/натискаючи вхідний/вихідний роз’єм і клацаючи/відпускаючи вихідний/вхідний роз’єм:

```ts
connection.addPreset(ConnectionPresets.classic.setup())
```

який еквівалентний наведеному нижче коду:

```ts
import { ClassicFlow } from 'rete-connection-plugin'

connection.addPreset(() => new ClassicFlow())
```

Якщо вхідне гніздо вже підключено, клацання або натискання на ньому призведе до видалення підключення та заміни його на псевдоз’єднання.

### Кастомний пресет {#custom-preset}

Якщо ви віддаєте перевагу альтернативному методу додавання підключень, ви можете скористатися `BidirectFlow`. У цьому режимі додавання вузла здійснюється клацанням миші на вхідному/вихідному сокеті та перетягуванням псевдоз’єднання на сокет протилежного типу.

```ts
import { ClassicFlow } from 'rete-connection-plugin'

connection.addPreset(() => new BidirectFlow())
```

Крім того, використовуючи дані початкового сокета, ви можете вибрати певний флоу або взагалі вимкнути взаємодію з певним сокетом

```ts
connection.addPreset(({ nodeId, side, key }) => {
  if (isReadonly(nodeId, side, key)) return undefined
  if (usesBidirect(nodeId, side, key)) return new BidirectFlow()
  return new ClassicFlow()
})
```

Якщо існуючі флоу не відповідають вашим потребам, ви можете реалізувати власне рішення, посилаючись на [вихідний код](https://github.com/retejs/connection-plugin/blob/next/src/flow/builtin/bidirect.ts) існуючих.

## Розширена поведінка {#enhanced-behavior}

Покращення поведінки існуючих пресетів може включати відстеження подій `connectionpick` і `connectiondrop`

```ts
connection.addPipe(context => {
  if (context.type === 'connectionpick') { // коли користувач натискає на сокет
    const { socket } = context.data
  }
  if (context.type === 'connectiondrop') { // коли користувач натискає на сокет або будь-яку область
    const { socket, initial, created } = context.data
  }
  return context
})
```

Подію `connectionpick` можна запобігти

```ts
connection.addPipe(context => {
  if (context.type === 'connectionpick') {
    if (readonly) return
  }
})
```

## З’єднання, створене користувачем {#user-created-connection}

За замовчуванням, коли користувач створює з’єднання за допомогою UI, плагін додає з’єднання як об’єкт, а не екземпляр класу, наприклад `ClassicPreset.Connection`. Якщо ви хочете налаштувати процес додавання цих з’єднань, укажіть опцію `makeConnection` у `ClassicFlow` або `BidirectFlow`.

```ts
import { getSourceTarget } from 'rete-connection-plugin'

connection.addPreset(() => new ClassicFlow({
  makeConnection(from, to, context) {
    const [source, target] = getSourceTarget(from, to) || [null, null];
    const { editor } = context;

    if (source && target) {
      editor.addConnection(
        new MyConnection(
          editor.getNode(source.nodeId),
          source.key,
          editor.getNode(target.nodeId),
          target.key
        )
      );
      return true; // переконайтеся, що підключення було успішно додано
    }
  }
}))
```

Крім того, використання `getSourceTarget` є важливим у цьому випадку, оскільки параметри `from` і `to` несуть дані про початковий і кінцевий сокети, які не обов’язково можуть збігатися з вихідним і вхідним сокетами.
