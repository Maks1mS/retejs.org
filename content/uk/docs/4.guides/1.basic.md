# Базовий редактор

::alert
Цей гайд містить `rete-react-render-plugin`. Ви можете використовувати його в будь-якому додатку, незалежно від фреймворку, який ви використовуєте (**React.js**, **Vue.js** або **Angular**).

Слідуйте цьому гайду, щоб використовувати відповідний плагін візуалізації у своєму **Angular** або **Vue.js** додатку, з посиланням на відповідні гайди [для Angular](/uk/docs/renderers/angular) або [для Vue.js](/uk/docs/ renderers/vue)
::

Щоб виконати цей гайд, ви можете створити додаток на **[Codesandbox](https://codesandbox.io)**, вибравши будь-який шаблон клієнтського додатку, або створити додаток локально.

#### Встановити залежності

```bash
npm i rete@next rete-area-plugin@next rete-connection-plugin@next rete-react-render-plugin@next rete-render-utils@next styled-components@next react@18 react-dom@18
```

#### Визначення типів та ініціалізація екземпляра редактора

```ts
import { NodeEditor, GetSchemes, ClassicPreset } from "rete";

type Schemes = GetSchemes<
  ClassicPreset.Node,
  ClassicPreset.Connection<ClassicPreset.Node, ClassicPreset.Node>
>;

const editor = new NodeEditor<Schemes>();
```
де `Schemes` — це тип, який допоможе вам з виведенням типів під час налаштування плагіна. Для більш складних прикладів може знадобитися розширити класи `ClassicPreset.Node` і `ClassicPreset.Connection`.

#### Додайте довільний вузол

Створення вузла, який містить один елемент керування та вихідний порт. Майте на увазі, що `addNode` є асинхронним методом.

```ts
const socket = new ClassicPreset.Socket("socket");

const nodeA = new ClassicPreset.Node("A");
nodeA.addControl("a", new ClassicPreset.InputControl("text", {}));
nodeA.addOutput("a", new ClassicPreset.Output(socket));
await editor.addNode(nodeA);
```


#### Створіть область для рендерінгу за допомогою React.js

Розмістіть цей код перед викликом `addNode`:

```ts
import { createRoot } from "react-dom/client";
import { AreaPlugin } from "rete-area-plugin";
import { ReactRenderPlugin, Presets, ReactArea2D } from "rete-react-render-plugin";

type AreaExtra = ReactArea2D<Schemes>;

const area = new AreaPlugin<Schemes, AreaExtra>(container);
const render = new ReactRenderPlugin<Schemes>({ createRoot });

render.addPreset(Presets.classic.setup({ area }));

editor.use(area);
area.use(render);
```
де
- `container` - це HTMLElement, де буде розміщено редактор
- тип `AreaExtra` дозволяє включати спеціальні візуальні елементи, оскільки за замовчуванням доступні лише `node` і `connection`

#### Додавання ще одного вузла

```ts
const nodeB = new ClassicPreset.Node("B");
nodeB.addControl("b", new ClassicPreset.InputControl("text", {}));
nodeB.addInput("b", new ClassicPreset.Input(socket));
await editor.addNode(nodeB);
```

Давайте встановимо зв'язок між цими вузлами

```ts
await editor.addConnection(new ClassicPreset.Connection(nodeA, "a", nodeB, "b"));
```

#### Позиціонування вузла

На екрані буде показано два вузли, що перекриваються, але ми можемо змінити позицію другого вузла.

```ts
await area.translate(nodeB.id, { x: 270, y: 0 });
```

### Інтерактивні зв'язки

Ця функція дозволяє користувачам взаємодіяти з вузлами.

```ts
import { ConnectionPlugin, Presets as ConnectionPresets } from "rete-connection-plugin"

const connection = new ConnectionPlugin<Schemes, AreaExtra>();

connection.addPreset(ConnectionPresets.classic.setup())

area.use(connection);
```

#### Пристосувати вьюпорт

Використовуйте розширення `zoomAt`, щоб автоматично пристосувати вьюпорт відповідно до всіх вузлів.

```ts
import { AreaExtensions } from "rete-area-plugin";

AreaExtensions.zoomAt(area, editor.getNodes());
```

#### Вибір вузлів

Крім того, розширення пропонують різні можливості, як-от можливість вибору вузлів користувачем.

```ts
AreaExtensions.selectableNodes(area, AreaExtensions.selector(), {
  accumulating: AreaExtensions.accumulateOnCtrl()
});
```

Для отримання додаткової інформації перегляньте гайд [Вибір](/uk/docs/selectable).

#### Порядок вузлів

Якщо ваш додаток дозволяє вибирати вузли, користувачі можуть захотіти переглядати вибрані вузли без будь-яких візуальних перешкод. Для полегшення цього передбачено додаткове розширення, яке автоматично виводить вибраний вузол на передній план.

```ts
AreaExtensions.simpleNodesOrder(area);
```

Перегляньте повний результат на сторінці прикладу [Базовий редактор](/uk/examples).
